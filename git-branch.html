<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="profile" href="http://gmpg.org/xfn/11">
        <link rel="pingback" href="https://dev.tencent.com/help/xmlrpc.php">
        <title>Git 分支操作 &#8211; 腾讯云开发者平台帮助中心</title>

<link rel="alternate" type="application/rss+xml" title="腾讯云开发者平台帮助中心 &raquo; Feed" href="https://dev.tencent.com/help/feed">
<link rel="alternate" type="application/rss+xml" title="腾讯云开发者平台帮助中心 &raquo; 评论Feed" href="https://dev.tencent.com/help/comments/feed">
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/dev.tencent.com\/help\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.8.12"}};
			!function(a,b,c){function d(a){var b,c,d,e,f=String.fromCharCode;if(!k||!k.fillText)return!1;switch(k.clearRect(0,0,j.width,j.height),k.textBaseline="top",k.font="600 32px Arial",a){case"flag":return k.fillText(f(55356,56826,55356,56819),0,0),b=j.toDataURL(),k.clearRect(0,0,j.width,j.height),k.fillText(f(55356,56826,8203,55356,56819),0,0),c=j.toDataURL(),b!==c&&(k.clearRect(0,0,j.width,j.height),k.fillText(f(55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447),0,0),b=j.toDataURL(),k.clearRect(0,0,j.width,j.height),k.fillText(f(55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447),0,0),c=j.toDataURL(),b!==c);case"emoji4":return k.fillText(f(55358,56794,8205,9794,65039),0,0),d=j.toDataURL(),k.clearRect(0,0,j.width,j.height),k.fillText(f(55358,56794,8203,9794,65039),0,0),e=j.toDataURL(),d!==e}return!1}function e(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g,h,i,j=b.createElement("canvas"),k=j.getContext&&j.getContext("2d");for(i=Array("flag","emoji4"),c.supports={everything:!0,everythingExceptFlag:!0},h=0;h<i.length;h++)c.supports[i[h]]=d(i[h]),c.supports.everything=c.supports.everything&&c.supports[i[h]],"flag"!==i[h]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[i[h]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='stylesheet' id='toc-screen-css' href='static/css/screen.min-1509.css' type='text/css' media='all'>
<link rel='stylesheet' id='ht-theme-style-css' href='static/css/style-4.8.12.css' type='text/css' media='all'>
<style id='ht-theme-style-inline-css' type='text/css'>
a, a:visited, .bbp-author-name { color: #32a3cb; } a:hover { color: #32a3cb; } #site-header { background: #2e97bd; } @media screen and (max-width: 768px) { #nav-primary-menu { background: #2e97bd; } } #site-header, #site-header a, #site-header a:visited, #site-header a:hover, #nav-primary button { color:#ffffff; } #page-header { background-image: linear-gradient(0deg, #91BBFF 0%, #4989FB 100%);; } #page-header, #page-header a, #page-header a:visited, #page-header a:hover, #page-header #page-header-title { color:#ffffff; } #page-header #page-header-tagline { color:rgba(255,255,255,0.9); } #ht-site-container.ht-layout-boxed { max-width: 1200px; box-shadow: 0 0 55px rgba(0,0,0,0.15); } #homepage-features .hf-block i { color: #32a3cb; } .hkb_widget_exit__btn { background: #212B3A; font-family: PingFangSC-Regular; font-size: 14px; color: #FFFFFF; line-height: 20px; }
</style>
<link rel='stylesheet' id='ht-kb-css' href='static/css/ht-kb-4.8.12.css' type='text/css' media='all'>
<link rel='stylesheet' id='font-awesome-css' href='static/css/font-awesome.min-4.8.12.css' type='text/css' media='all'>
<script type='text/javascript' src='static/js/jquery-1.12.4.js'></script>
<script type='text/javascript' src='static/js/jquery-migrate.min-1.4.1.js'></script>
<link rel='https://api.w.org/' href='https://dev.tencent.com/help/wp-json/'>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://dev.tencent.com/help/xmlrpc.php?rsd">
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://dev.tencent.com/help/wp-includes/wlwmanifest.xml"> 
<link rel='prev' title='Git 基础操作' href='git-base.html'>
<link rel='next' title='任务管理' href='bbe5a1aee786.html'>
<meta name="generator" content="WordPress 4.8.12">
<link rel="canonical" href="">
<link rel='shortlink' href='https://dev.tencent.com/help/?p=6454'>
<link rel="alternate" type="application/json+oembed" href="https://dev.tencent.com/help/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fdev.tencent.com%2Fhelp%2Fdoc%2Fgit-2%2Fgit-branch">
<link rel="alternate" type="text/xml+oembed" href="https://dev.tencent.com/help/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fdev.tencent.com%2Fhelp%2Fdoc%2Fgit-2%2Fgit-branch&#038;format=xml">
<meta name="generator" content="HelpGuru Knowledge Base v3.0.0">
<script type="text/javascript">
	window._se_plugin_version = '8.1.9';
</script>
<!--[if lt IE 9]><script src="static/js/html5.js"></script><![endif]--><!--[if (gte IE 6)&(lte IE 8)]><script src="static/js/selectivizr-min.js"></script><![endif]-->


<meta name="msapplication-TileImage" content="https://help-assets.codehub.cn/tencent/2018/09/cropped-cloud.png">
		<style type="text/css" id="wp-custom-css">
			/*
您可以在此处加入您的CSS。

点击上方的帮助图标来了解更多。
*/
.hkb-subcats__cat .hkb-article-list{
display:none
}


.hkb-subcats .hkb-subcats__cat:before{
content:none
}
.hkb-subcats .hkb-subcats__cat{
    font-size: 14px;
    line-height: 22px;
    list-style-type: disc;
    padding-left: 8px;
padding-bottom: 20px;
}


.hkb-subcats{
margin: 10px 0 0;
    font-size: 14px;
    line-height: 22px;
    list-style-type: disc;
    padding-left: 28px;
}

.hkb-subcats > li{
margin-bottom:0px;
}		</style>
	        
    </head>
<body class="ht_kb-template-default single single-ht_kb postid-6454 single-format-standard ht-kb chrome" itemtype="http://schema.org/WebPage" itemscope="itemscope">
<style>
html.header-expanded {
  overflow: hidden;
}
.header-container {
  width: 100%;
  font-size: 14px;
  z-index: 1000;
}
.header-container .header-nav {
  height: 40px;
  align-items: center;
  background: #2b303b;
  font-size: 12px;
  margin-top: 1px;
  display: none;
}
.header-container .header-nav.active {
  position: fixed;
  width: 100%;
  top: -1px;
  left: 0;
}
.header-container .header-nav .item {
  color: #fff;
  margin-left: 30px;
  cursor: pointer;
}
.header-container .header-nav .item.active {
  color: #00a4ff;
}
.header-container .header-content {
  height: 60px;
  padding: 0 30px;
  background: #2b303b;
  position: relative;
  z-index: 1001;
}
.header-container .header-content .header-body {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: 100%;
}
.header-container .header-content .header-body .left-zone {
  position: relative;
  top: 1px;
}
.header-container .logo img {
  height: 24px;
  width: 176px;
}
.header-container .logo, .header-container .icon, .header-container .nav {
  display: inline-block;
}
.header-container .nav .nav-item {
  float: left;
  padding: 0 15px;
  color: #fff;
  position: relative;
  top: 1px;
}
.header-container .nav .nav-item span, .header-container .nav .nav-item a {
  cursor: pointer;
  text-decoration: none;
  color: #fff;
}
.header-container .login-zone {
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
}
.header-container .icon {
  align-items: center;
  justify-content: space-between;
  flex-direction: column;
  cursor: pointer;
  display: none;
}
.header-container .icon i {
  display: inline-block;
  height: 3px;
  width: 18px;
  background-color: #fff;
  margin-bottom: 3px;
}
.header-container .icon i:last-of-type {
  margin-bottom: 0;
}
.header-container .icon-hide {
  position: relative;
  width: 18px;
  height: 18px;
  display: none;
}
.header-container .icon-hide i {
  display: inline-block;
  height: 4px;
  width: 18px;
  background-color: #fff;
  transform: rotate(-45deg);
  position: absolute;
  top: 9px;
  left: 0;
  border-radius: 1px;
}
.header-container .icon-hide i:last-of-type {
  transform: rotate(45deg);
}
.header-container .login-zone {
  display: flex;
}
.header-container .login-zone .avatar {
  display: none;
}
.header-container .login-zone .register a, .header-container .login-zone .login a {
  color: #fff;
  text-decoration: unset;
}
.header-container .login-zone .register a {
  position: relative;
  padding-right: 10px;
  margin-right: 10px;
}
.header-container .login-zone .register a::after {
  content: ' ';
  height: 14px;
  background-color: #fff;
  width: 1px;
  position: absolute;
  right: 0;
  top: 3px;
  cursor: default;
}
.header-container .login-zone .register .button {
  background: #06f;
  color: #fff;
}
.header-container .login-zone .login .button {
  background: #ebeff5;
  color: #000;
}
.header-container .login-zone .avatar img {
  border-radius: 50%;
  width: 40px;
  height: 40px;
  vertical-align: middle;
}
.header-container .icon svg {
  vertical-align: middle;
  cursor: pointer;
}
.header-container .icon .close, .header-container .icon .more {
  display: none;
}
.header-container .icon .close.show, .header-container .icon .more.show {
  display: inherit;
}
.header-container.logged-in .login-zone .register, .header-container.logged-in .login-zone .login {
  display: none !important;
}
.header-container.logged-in .login-zone .avatar {
  display: inline-block !important;
}
.header-container.login-checked .login-zone .register, .header-container.login-checked .login-zone .login {
  display: inline-block;
}
@media only screen and (max-width: 1024px) {
  .header-container .header-content {
    padding: 0 1rem;
  }
}
@media only screen and (max-width: 768px) {
  .header-content {
    padding: 0 20px !important;
  }
  .header-container .nav, .header-container .login-zone {
    display: none;
  }
  .header-container .header-content {
    padding: 0 1rem;
  }
  .header-container .icon {
    display: flex;
  }
}
@media only screen and (max-width: 414px) {
  .header-nav {
    display: none !important;
  }
  .header-container {
    position: fixed;
    width: 100%;
    top: 0;
    left: 0;
  }
  .header-content {
    height: 60px !important;
  }
  .header-content .header-body .left-zone {
    height: 21px;
  }
  .header-content .header-body .left-zone .logo img {
    height: 20px;
    width: 147px;
  }
}
.mobile-header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 1000;
  background-color: #15171a;
}
.mobile-header .icon {
  position: absolute;
  right: 20px;
  top: 20px;
  height: 30px;
  width: 30px;
}
.mobile-header .icon i {
  width: 3px;
  height: 20px;
  background-color: #000;
  position: absolute;
  top: 50%;
  left: 50%;
}
.mobile-header .icon .left {
  transform: rotate(45deg);
}
.mobile-header .icon .right {
  transform: rotate(-45deg);
}
.mobile-header .nav {
  display: block;
  padding-top: 60px;
  color: #fff;
}
.mobile-header .nav .nav-item {
  height: 50px;
  line-height: 50px;
  padding-left: 20px;
  box-shadow: 0 1px 0 0 #3d404b;
  font-size: 16px;
  width: 100%;
}
.mobile-header .nav .nav-item .grey {
  opacity: 0.5;
}
.mobile-header .nav .nav-item.nav-out {
  box-shadow: none;
  height: auto;
  line-height: 1.5;
}
.mobile-header .nav .nav-item.nav-avatar {
  margin: 20px 0 0 20px;
  width: 42px;
  height: 42px;
  overflow: hidden;
  border-radius: 50%;
  padding: 0;
}
.mobile-header .nav .nav-item.nav-avatar img {
  height: 100%;
  width: 100%;
}
.mobile-header .nav .nav-item a {
  color: #fff;
}
.mobile-header .nav .nav-item a.sub {
  padding-left: 30px;
}
.drop-down-wrap {
  position: relative;
}
.drop-down-wrap:hover .drop-down-container {
  display: block;
}
.drop-down-wrap .drop-down-container {
  display: none;
  top: 20px;
  position: absolute;
  padding-top: 10px;
}
.drop-down-wrap .drop-down-container .drop-down {
  font-size: 12px;
  color: #202d40;
  border: 1px solid #f5f6f8;
  width: 140px;
  border-radius: 2px 2px 2px 2px;
  background: #fff;
  position: relative;
}
.drop-down-wrap .drop-down-container .drop-down:after {
  content: ' ';
  position: absolute;
  top: -6px;
  left: 7px;
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 0 6px 6px 6px;
  border-color: transparent transparent #fff transparent;
}
.drop-down-wrap .drop-down-container .drop-down .item {
  padding-left: 10px;
  height: 36px;
  line-height: 36px;
  cursor: pointer;
  text-align: left !important;
}
.drop-down-wrap .drop-down-container .drop-down .item a {
  color: #202d40;
}
.drop-down-wrap .drop-down-container .drop-down .item:hover {
  background-color: #f5f7fa;
}
@keyframes line-spin-fade-loader {
  50% {
    opacity: 0.3;
  }
  100% {
    opacity: 1;
  }
}
.loading {
  margin-right: 30px;
}
.line-spin-fade-loader {
  transform: scale(0.4);
  position: relative;
}
.line-spin-fade-loader > div:nth-child(1) {
  top: 20px;
  left: 0;
  -webkit-animation: line-spin-fade-loader 1.2s 0.12s infinite ease-in-out;
  animation: line-spin-fade-loader 1.2s 0.12s infinite ease-in-out;
}
.line-spin-fade-loader > div:nth-child(2) {
  top: 13.63636px;
  left: 13.63636px;
  -webkit-transform: rotate(-45deg);
  -ms-transform: rotate(-45deg);
  transform: rotate(-45deg);
  -webkit-animation: line-spin-fade-loader 1.2s 0.24s infinite ease-in-out;
  animation: line-spin-fade-loader 1.2s 0.24s infinite ease-in-out;
}
.line-spin-fade-loader > div:nth-child(3) {
  top: 0;
  left: 20px;
  -webkit-transform: rotate(90deg);
  -ms-transform: rotate(90deg);
  transform: rotate(90deg);
  -webkit-animation: line-spin-fade-loader 1.2s 0.36s infinite ease-in-out;
  animation: line-spin-fade-loader 1.2s 0.36s infinite ease-in-out;
}
.line-spin-fade-loader > div:nth-child(4) {
  top: -13.63636px;
  left: 13.63636px;
  -webkit-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  transform: rotate(45deg);
  -webkit-animation: line-spin-fade-loader 1.2s 0.48s infinite ease-in-out;
  animation: line-spin-fade-loader 1.2s 0.48s infinite ease-in-out;
}
.line-spin-fade-loader > div:nth-child(5) {
  top: -20px;
  left: 0;
  -webkit-animation: line-spin-fade-loader 1.2s 0.6s infinite ease-in-out;
  animation: line-spin-fade-loader 1.2s 0.6s infinite ease-in-out;
}
.line-spin-fade-loader > div:nth-child(6) {
  top: -13.63636px;
  left: -13.63636px;
  -webkit-transform: rotate(-45deg);
  -ms-transform: rotate(-45deg);
  transform: rotate(-45deg);
  -webkit-animation: line-spin-fade-loader 1.2s 0.72s infinite ease-in-out;
  animation: line-spin-fade-loader 1.2s 0.72s infinite ease-in-out;
}
.line-spin-fade-loader > div:nth-child(7) {
  top: 0;
  left: -20px;
  -webkit-transform: rotate(90deg);
  -ms-transform: rotate(90deg);
  transform: rotate(90deg);
  -webkit-animation: line-spin-fade-loader 1.2s 0.84s infinite ease-in-out;
  animation: line-spin-fade-loader 1.2s 0.84s infinite ease-in-out;
}
.line-spin-fade-loader > div:nth-child(8) {
  top: 13.63636px;
  left: -13.63636px;
  -webkit-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  transform: rotate(45deg);
  -webkit-animation: line-spin-fade-loader 1.2s 0.96s infinite ease-in-out;
  animation: line-spin-fade-loader 1.2s 0.96s infinite ease-in-out;
}
.line-spin-fade-loader > div {
  background-color: #279fcf;
  width: 4px;
  height: 35px;
  border-radius: 2px;
  margin: 2px;
  -webkit-animation-fill-mode: both;
  animation-fill-mode: both;
  position: absolute;
  width: 5px;
  height: 15px;
}
.loading-btn .line-spin-fade-loader > div {
  background-color: #fff;
}

</style>
<header class="header-container clearfix">
    <div class="header-content">
        <div class="header-body">
            <div class="left-zone">
                <div class="logo">
                    <a href="index.html">
                        <img src="static/picture/cd329f9b-3c29-4485-a061-af401cab.png" srcset="static/picture/114dd24b-7ac5-45ce-8af7-3c741a15.png 2x">
                    </a>
                </div>
                <div class="nav">
                    <div class="nav-item drop-down-wrap">
                        <span>产品</span>
                        <div class="drop-down-container">
                          <div class="drop-down">
                                <div class="item">
                                    <a href="production.html" target="_blank">
                                        CODING 个人版
                                    </a>
                                </div>
                                <div class="item">
                                    <a href="index1.html" target="_blank">
                                        Cloud Studio
                                    </a>
                                </div>
                                <div class="item">
                                    <a href="javascript:;" target="_blank">
                                        CODING 企业版
                                    </a>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="nav-item">
                        <a href="help.html" target="_blank">文档</a>
                    </div>
                </div>
            </div>

        </div>
    </div>
</header>


<!-- #ht-site-container -->
<div id="ht-site-container" class="clearfix ht-layout-fullwidth">

    <!-- #header -->
<!--    <header id="site-header" class="clearfix" role="banner" itemtype="http://schema.org/WPHeader" itemscope="itemscope">
    <div class="ht-container clearfix">-->

    <!-- #logo -->
<!--    <div id="logo">
        <a title="" href="">
            <img alt="" src="" />
                                    <h1 class="site-title" itemprop="headline"></h1>
                        </a>
    </div>-->
    <!-- /#logo -->

    <!-- /#header -->
<!-- #page-header -->
<style>

#page-header {
    height: 400px;
    background-image: linear-gradient(-196.74378039254296deg, #0C1425 0%, #24314A 58.02%, #2B3C62 100%) !important;
    padding: 0 !important;
    text-alg
}
#page-header  .page-header-container {
    background-image: url("static/image/444d6995-d015-492b-9341-549f5b29.png");
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    height: 100%;
    width: 100%;
    display: flex;
    align-items: center;
    text-align: center;
}
#page-header  #page-header-title {
    font-size: 46px;
    line-height: unset !important;
    height: unset !important;
    padding-bottom: 10px;
}
#page-header .hkb-site-search {
    display: inline-block;
}
#page-header .fa-search {
    left: 17px !important;
}
@media only screen and (max-width: 414px) {
    #page-header .page-header-container {
        background-size: auto;
    }
    #page-header #page-header-title {
        line-height: 1.4 !important;
    }
    #page-header .fa-search {
        left: 29px !important;
    }
}
</style>
<section id="page-header" class="clearfix">
<div class="page-header-container">
    <div class="ht-container">
        <h1 id="page-header-title">
            腾讯云开发者平台帮助文档
        </h1>
    	
        <form class="hkb-site-search" style="position: relative;" method="get" action="https://dev.tencent.com/help/">
        <span class="fa fa-search" style="font-size: 14px;color: #323A45;position: absolute;top: 18px;left: 295px;"></span>
        <label class="hkb-screen-reader-text" for="s">Search For</label>
        <input class="hkb-site-search__field" type="text" value="" placeholder="请输入你的疑问" style="padding-left: 38px;" name="s" autocomplete="off">
        <input type="hidden" name="ht-kb-search" value="1">
        <input type="hidden" name="lang" value="">
<!--         <button class="hkb-site-search__button" type="submit"><span>搜索</span></button>
 -->    </form>
    </div>
</div>
</section>
<!-- /#page-header -->

<!-- #page-header-breadcrumbs -->
<section id="page-header-breadcrumbs" class="clearfix">
<div class="ht-container">
		

<!-- .hkb-breadcrumbs -->
            <ol class="hkb-breadcrumbs" itemscope="" itemtype="http://schema.org/BreadcrumbList">
                                        <li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem">
                    <a itemprop="item" href="help.html" title="首页">
                        <span itemprop="name">首页</span>
                    </a>
                    <meta itemprop="position" content="1">
                </li>               
                            <li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem">
                    <a itemprop="item" href="git-2.html" title="View all posts in Git帮助手册">
                        <span itemprop="name">Git帮助手册</span>
                    </a>
                    <meta itemprop="position" content="2">
                </li>               
                            <li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem">
                    <a itemprop="item" href="" title="Git 分支操作">
                        <span itemprop="name">Git 分支操作</span>
                    </a>
                    <meta itemprop="position" content="3">
                </li>               
                    </ol>
    <!-- /.hkb-breadcrumbs -->
</div>
</section>
<!-- /#page-header -->
<!-- #primary -->
<div id="primary" class="sidebar-left clearfix"> 
<div class="ht-container">

<!-- #content -->
<main id="content" role="main" itemscope="itemscope" itemprop="mainContentOfPage">
<!-- #ht-kb -->
<div id="hkb" class="hkb-template-single">

	
		<article id="post-6454" class="post-6454 ht_kb type-ht_kb status-publish format-standard hentry ht_kb_category-git-2 ht_kb_tag-doc" itemtype="http://schema.org/CreativeWork" itemscope="itemscope">

		<!-- .entry-header -->
		<header class="entry-header">

		
			<h1 class="entry-title" itemprop="headline">
				Git 分支操作			</h1>

<!--			<ul class="hkb-entry-meta clearfix">

				<li class="hkb-em-date"> 
				    <span>Created</span>
				    <a href="https://dev.tencent.com/help/doc/git-2/git-branch" rel="bookmark" itemprop="url"><time datetime="2018-12-19" itemprop="datePublished">2018年12月19日</time></a>
				</li>
				<li class="ht-kb-em-author">
					<span>Author</span>
					<a class="url fn n" href="https://dev.tencent.com/help/author/chenhang" title="chenhang" rel="me" itemprop="author">chenhang</a>
				</li>
									<li class="ht-kb-em-category">
					    <span>Category</span>
					     <a href="https://dev.tencent.com/help/doc/git-2" rel="tag">Git帮助手册</a>					</li>
								
			</ul>
-->

				    
		</header>
		<!-- /.entry-header --> 

			<div class="hkb-entry-content">

					<!-- .hkb-article__content -->
<div class="hkb-article__content entry-content" itemprop="text">
    <div id="toc_container" class="no_bullets"><p class="toc_title">文章内容</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 分支简介</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">2</span> 分支的新建与合并</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">3</span> 分支管理</a></li><li><a href="#i-4"><span class="toc_number toc_depth_1">4</span> 分支开发工作流</a></li><li><a href="#i-5"><span class="toc_number toc_depth_1">5</span> 远程分支</a></li><li><a href="#i-6"><span class="toc_number toc_depth_1">6</span> 变基</a></li><li><a href="#i-7"><span class="toc_number toc_depth_1">7</span> 总结</a></li></ul></div>
<h1 id="r_git_branches_overview" id="%e5%88%86%e6%94%af%e7%ae%80%e4%bb%8b"><span id="i">分支简介</span></h1>
<div class="paragraph">
<p>为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。</p>
</div>
<div class="paragraph">
<p>或许你还记得 起步 的内容，Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。</p>
</div>
<div class="paragraph">
<p>在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，</p>
</div>
<div class="paragraph">
<p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用我们在 起步 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：</p>
</div>
<p><code class="language-console" data-lang="console">$ git add README test.rb LICENSE<br>
$ git commit -m 'The initial commit of my project'</code></p>
<div class="paragraph">
<p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p>
</div>
<div class="paragraph">
<p>现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/commit-and-tree.png" alt="首次提交对象及其树结构。"></div>
<div class="title">Figure 9. 首次提交对象及其树结构</div>
</div>
<div class="paragraph">
<p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/commits-and-parents.png" alt="提交对象及其父对象。"></div>
<div class="title">Figure 10. 提交对象及其父对象</div>
</div>
<div class="paragraph">
<p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 它会在每次的提交操作中自动向前移动。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 <code>git init</code> 命令默认创建它，并且大多数人都懒得去改动它。</p>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/branch-and-history.png" alt="分支及其提交历史。"></div>
<div class="title">Figure 11. 分支及其提交历史</div>
</div>
<div class="sect3">
<p id="r_create_new_branch"><strong>分支创建</strong></p>
<div class="paragraph">
<p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p>
</div>
<p><code class="language-console" data-lang="console">$ git branch testing</code></p>
<div class="paragraph">
<p>这会在当前所在的提交对象上创建一个指针。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/two-branches.png" alt="两个指向相同提交历史的分支。"></div>
<div class="title">Figure 12. 两个指向相同提交历史的分支</div>
</div>
<div class="paragraph">
<p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 <em>创建</em> 一个新分支，并不会自动切换到新分支中去。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/head-to-master.png" alt="HEAD 指向当前所在的分支。"></div>
<div class="title">Figure 13. HEAD 指向当前所在的分支</div>
</div>
<div class="paragraph">
<p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code></p>
</div>
<p><code class="language-console" data-lang="console">$ git log --oneline --decorate<br>
f30ab (HEAD, master, testing) add feature #32 - ability to add new<br>
34ac2 fixed bug #1328 - stack overflow under certain conditions<br>
98ca9 initial commit of my project</code></p>
</div>
<div class="paragraph">
<p>正如你所见，当前 “master” 和 “testing” 分支均指向校验和以 <code>f30ab</code> 开头的提交对象。</p>
</div>
<div class="sect3">
<p id="r_switching_branches"><strong>分支切换</strong></p>
<div class="paragraph">
<p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout testing</code></p>
</div>
<div class="paragraph">
<p>这样 HEAD 就指向 testing 分支了。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/head-to-testing.png" alt="HEAD 指向当前所在的分支。"></div>
<div class="title">Figure 14. HEAD 指向当前所在的分支</div>
</div>
<div class="paragraph">
<p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p>
</div>
<p><code class="language-console" data-lang="console">$ vim test.rb<br>
$ git commit -a -m 'made a change'</code></p>
<div class="imageblock">
<div class="content"><img src="static/picture/advance-testing.png" alt="HEAD 分支随着提交操作自动向前移动。"></div>
<div class="title">Figure 15. HEAD 分支随着提交操作自动向前移动</div>
</div>
<div class="paragraph">
<p>如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout master</code></p>
<div class="imageblock">
<div class="content"><img src="static/picture/checkout-master.png" alt="检出时 HEAD 随之移动。"></div>
<div class="title">Figure 16. 检出时 HEAD 随之移动</div>
</div>
<div class="paragraph">
<p>这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing分支所做的修改，以便于向另一个方向进行开发。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">分支切换会改变你工作目录中的文件</div>
<div class="paragraph">
<p>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>我们不妨再稍微做些修改并提交：</p>
</div>
<p><code class="language-console" data-lang="console">$ vim test.rb<br>
$ git commit -a -m 'made other changes'</code></p>
<div class="paragraph">
<p>现在，这个项目的提交历史已经产生了分叉。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。</p>
</div>
<div id="rdivergent_history" class="imageblock">
<div class="content"><img src="static/picture/advance-master.png" alt="项目分叉历史。"></div>
<div class="title">Figure 17. 项目分叉历史</div>
</div>
<div class="paragraph">
<p>你可以简单地使用 git log 命令查看分叉历史。 运行 git log &#8211;oneline &#8211;decorate &#8211;graph &#8211;all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
</div>
<p><code class="language-console" data-lang="console">$ git log --oneline --decorate --graph --all<br>
* c2b9e (HEAD, master) made other changes<br>
| * 87ab2 (testing) made a change<br>
|/<br>
* f30ab add feature #32 - ability to add new formats to the<br>
* 34ac2 fixed bug #1328 - stack overflow under certain conditions<br>
* 98ca9 initial commit of my project</code></p>
<div class="paragraph">
<p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？</p>
</div>
<div class="paragraph">
<p>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。</p>
</div>
<div class="paragraph">
<p>接下来，让我们看看你为什么应该这样做。</p>
<h1 id="_分支的新建与合并" id="%e5%88%86%e6%94%af%e7%9a%84%e6%96%b0%e5%bb%ba%e4%b8%8e%e5%90%88%e5%b9%b6"><span id="i-2">分支的新建与合并</span></h1>
<div class="paragraph">
<p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>开发某个网站。</li>
<li>为实现某个新的需求，创建一个分支。</li>
<li>在这个分支上开展工作。</li>
</ol>
</div>
<div class="paragraph">
<p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>切换到你的线上分支（production branch）。</li>
<li>为这个紧急任务新建一个分支，并在其中修复它。</li>
<li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li>
<li>切换回你最初工作的分支上，继续工作。</li>
</ol>
</div>
<div class="sect3">
<p id="r_basic_branching"><strong>新建分支</strong></p>
<div class="paragraph">
<p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/basic-branching-1.png" alt="一个简单的提交历史。"></div>
<div class="title">Figure 18. 一个简单提交历史</div>
</div>
<div class="paragraph">
<p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 -b 参数的 git checkout 命令：</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout -b iss53<br>
Switched to a new branch "iss53"</code></p>
</div>
</div>
<div class="paragraph">
<p>它是下面两条命令的简写：</p>
</div>
<p><code class="language-console" data-lang="console">$ git branch iss53<br>
$ git checkout iss53</code></p>
<div class="imageblock">
<div class="content"><img src="static/picture/basic-branching-2.png" alt="创建一个新分支指针。"></div>
<div class="title">Figure 19. 创建一个新分支指针</div>
</div>
<div class="paragraph">
<p>你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，iss53 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 HEAD 指针指向了 iss53 分支）</p>
</div>
<p><code class="language-console" data-lang="console">$ vim index.html<br>
$ git commit -a -m 'added a new footer [issue 53]'</code></p>
<div class="imageblock">
<div class="content"><img src="static/picture/basic-branching-3.png" alt="iss53 分支随着工作的进展向前推进。"></div>
<div class="title">Figure 20. iss53 分支随着工作的进展向前推进</div>
</div>
<div class="paragraph">
<p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 iss53 的修改混在一起，你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 master 分支。</p>
</div>
<div class="paragraph">
<p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending））。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 master 分支了：</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout master<br>
Switched to branch 'master'</code></p>
<div class="paragraph">
<p>这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p>
</div>
<div class="paragraph">
<p>接下来，你要修复这个紧急问题。 让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout -b hotfix<br>
Switched to a new branch 'hotfix'<br>
$ vim index.html<br>
$ git commit -a -m 'fixed the broken email address'<br>
[hotfix 1fb7853] fixed the broken email address<br>
1 file changed, 2 insertions(+)</code></p>
<div class="imageblock">
<div class="content"><img src="static/picture/basic-branching-4.png" alt="基于 &#96;master&#96; 分支的紧急问题分支（hotfix branch）。"></div>
<div class="title">Figure 21. 基于 <code>master</code> 分支的紧急问题分支 <code>hotfix branch</code></div>
</div>
<div class="paragraph">
<p>你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的 master 分支来部署到线上。 你可以使用 git merge 命令来达到上述目的：</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout master<br>
$ git merge hotfix<br>
Updating f42c576..3a0874c<br>
Fast-forward<br>
index.html | 2 ++<br>
1 file changed, 2 insertions(+)</code></p>
<div class="paragraph">
<p>在合并的时候，你应该注意到了&#8221;快进（fast-forward）&#8221;这个词。 由于当前 master 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p>
</div>
<div class="paragraph">
<p>现在，最新的修改已经在 master 分支所指向的提交快照中，你可以着手发布该修复了。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/basic-branching-5.png" alt="&#96;master&#96; 被快进到 &#96;hotfix&#96;。"></div>
<div class="title">Figure 22. master 被快进到 hotfix</div>
</div>
<div class="paragraph">
<p>关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 hotfix分支，因为你已经不再需要它了 —— master 分支已经指向了同一个位置。 你可以使用带 -d 选项的 git branch 命令来删除分支：</p>
</div>
<p><code class="language-console" data-lang="console">$ git branch -d hotfix<br>
Deleted branch hotfix (3a0874c).</code></p>
<div class="paragraph">
<p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout iss53<br>
Switched to branch "iss53"<br>
$ vim index.html<br>
$ git commit -a -m 'finished the new footer [issue 53]'<br>
[iss53 ad82d7a] finished the new footer [issue 53]<br>
1 file changed, 1 insertion(+)</code></p>
<div class="imageblock">
<div class="content"><img src="static/picture/basic-branching-6.png" alt="继续在 &#96;iss53&#96; 分支上的工作。"></div>
<div class="title">Figure 23. 继续在 <code>iss53</code> 分支上的工作</div>
</div>
<div class="paragraph">
<p>你在 hotfix 分支上所做的工作并没有包含到 iss53 分支中。 如果你需要拉取 hotfix 所做的修改，你可以使用 git merge master 命令将 master 分支合并入 iss53 分支，或者你也可以等到 iss53 分支完成其使命，再将其合并回 master 分支。</p>
</div>
<div class="sect3">
<p id="r_basic_merging"><strong>分支的合并</strong></p>
<div class="paragraph">
<p>假设你已经修正了 #53 问题，并且打算将你的工作合并入 master 分支。 为此，你需要合并 iss53 分支到 master 分支，这和之前你合并 hotfix 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 git merge 命令：</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout master<br>
Switched to branch 'master'<br>
$ git merge iss53<br>
Merge made by the 'recursive' strategy.<br>
index.html |    1 +<br>
1 file changed, 1 insertion(+)</code></p>
</div>
<div class="paragraph">
<p>这和你之前合并 hotfix 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/basic-merging-1.png" alt="一次典型合并中所用到的三个快照。"></div>
<div class="title">Figure 24. 一次典型合并中所用到的三个快照</div>
</div>
<div class="paragraph">
<p>和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/basic-merging-2.png" alt="一个合并提交。"></div>
<div class="title">Figure 25. 一个合并提交</div>
</div>
<div class="paragraph">
<p>需要指出的是，Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的 CVS 系统或者 Subversion （1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。 Git 的这个优势使其在合并操作上比其他系统要简单很多。</p>
</div>
<div class="paragraph">
<p>既然你的修改已经合并进来了，你已经不再需要 iss53 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p>
</div>
<p><code class="language-console" data-lang="console">$ git branch -d iss53</code></p>
<div class="sect3">
<p id="r_basic_merge_conflicts"><strong>遇到冲突时的分支合并</strong></p>
<div class="paragraph">
<p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 hotfix 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p>
</div>
<p><code class="language-console" data-lang="console">$ git merge iss53<br>
Auto-merging index.html<br>
CONFLICT (content): Merge conflict in index.html<br>
Automatic merge failed; fix conflicts and then commit the result.</code></p>
</div>
<div class="paragraph">
<p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add &lt;file&gt;..." to mark resolution)

    both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p>
</div>
<p><code class="language-html" data-lang="html">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html<br>
&lt;div id="footer"&gt;contact : email.support@github.com&lt;/div&gt;<br>
=======<br>
&lt;div id="footer"&gt;<br>
please contact us at support@github.com<br>
&lt;/div&gt;<br>
&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</code></p>
<div class="paragraph">
<p>这表示 HEAD 所指示的版本（也就是你的 master 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（======= 的上半部分），而 iss53 分支所指示的版本在 ======= 的下半部分。 为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p>
</div>
<p><code class="language-html" data-lang="html">&lt;div id="footer"&gt;<br>
please contact us at email.support@github.com<br>
&lt;/div&gt;</code></p>
<div class="paragraph">
<p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 &lt;&lt;&lt;&lt;&lt;&lt;&lt; , ======= , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p>
</div>
<div class="paragraph">
<p>如果你想使用图形化工具来解决冲突，你可以运行 git mergetool，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p>
</div>
<p><code class="language-console" data-lang="console">$ git mergetool</code></p>
<p>This message is displayed because &#8216;merge.tool&#8217; is not configured.<br>
See &#8216;git mergetool &#8211;tool-help&#8217; or &#8216;git help config&#8217; for more details.<br>
&#8216;git mergetool&#8217; will now attempt to use one of the following tools:<br>
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge<br>
Merging:<br>
index.html</p>
<p>Normal merge conflict for &#8216;index.html&#8217;:<br>
{local}: modified file<br>
{remote}: modified file<br>
Hit return to start merge resolution tool (opendiff):</p>
<div class="paragraph">
<p>如果你想使用除默认工具（在这里 Git 使用  opendiff 做为默认的合并工具，因为作者在 Mac 上运行该程序）外的其他合并工具，你可以在 “下列工具中（one of the following tools）” 这句后面看到所有支持的合并工具。 然后输入你喜欢的工具名字就可以了。</p>
</div>
<div class="paragraph">
<p>等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 git status 来确认所有的合并冲突都已被解决：</p>
</div>
<p><code class="language-console" data-lang="console">$ git status<br>
On branch master<br>
All conflicts fixed but you are still merging.<br>
(use "git commit" to conclude merge)</code></p>
<p>Changes to be committed:</p>
<p>modified: index.html</p>
<div class="paragraph">
<p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p>
</div>
<p><code class="language-console" data-lang="console">Merge branch 'iss53'</code></p>
<p>Conflicts:<br>
index.html<br>
#<br>
# It looks like you may be committing a merge.<br>
# If this is not correct, please remove the file<br>
# .git/MERGE_HEAD<br>
# and try again.</p>
<p># Please enter the commit message for your changes. Lines starting<br>
# with &#8216;#&#8217; will be ignored, and an empty message aborts the commit.<br>
# On branch master<br>
# All conflicts fixed but you are still merging.<br>
#<br>
# Changes to be committed:<br>
# modified: index.html<br>
#</p>
<div class="paragraph">
<p>如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息，添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。</p>
<h1 id="r_branch_management" id="%e5%88%86%e6%94%af%e7%ae%a1%e7%90%86"><span id="i-3">分支管理</span></h1>
<div class="paragraph">
<p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p>
</div>
<div class="paragraph">
<p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p>
</div>
<p><code class="language-console" data-lang="console">$ git branch<br>
iss53<br>
* master<br>
testing</code></p>
</div>
<div class="paragraph">
<p>注意 master 分支前的 * 字符：它代表现在检出的那一个分支（也就是说，当前 HEAD 指针所指向的分支）。 这意味着如果在这时候提交，master 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令：</p>
</div>
<p><code class="language-console" data-lang="console">$ git branch -v<br>
iss53   93b412c fix javascript issue<br>
* master  7a98805 Merge branch 'iss53'<br>
testing 782fd34 add scott to the author list in the readmes</code></p>
<div class="paragraph">
<p>&#8211;merged 与 &#8211;no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 git branch &#8211;merged：</p>
</div>
<p><code class="language-console" data-lang="console">$ git branch --merged<br>
iss53<br>
* master</code></p>
<div class="paragraph">
<p>因为之前已经合并了 iss53 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p>
</div>
<div class="paragraph">
<p>查看所有包含未合并工作的分支，可以运行 git branch &#8211;no-merged：</p>
</div>
<p><code class="language-console" data-lang="console">$ git branch --no-merged<br>
testing</code></p>
<div class="paragraph">
<p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败：</p>
</div>
<p><code class="language-console" data-lang="console">$ git branch -d testing<br>
error: The branch 'testing' is not fully merged.<br>
If you are sure you want to delete it, run 'git branch -D testing'.</code></p>
<div class="paragraph">
<p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 -D 选项强制删除它。</p>
<h1 id="_分支开发工作流" id="%e5%88%86%e6%94%af%e5%bc%80%e5%8f%91%e5%b7%a5%e4%bd%9c%e6%b5%81"><span id="i-4">分支开发工作流</span></h1>
<div class="paragraph">
<p>现在你已经学会新建和合并分支，那么你可以或者应该用它来做些什么呢？ 在本节，我们会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出这些典型的工作模式，你可以根据项目实际情况选择一种用用看。</p>
</div>
<div class="sect3">
<p id="_长期分支"><strong>长期分支</strong></p>
<div class="paragraph">
<p>因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。</p>
</div>
<div class="paragraph">
<p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。</p>
</div>
<div class="paragraph">
<p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/lr-branches-1.png" alt="渐进稳定分支的线性图。"></div>
<div class="title">Figure 26. 渐进稳定分支的线性图</div>
</div>
<div class="paragraph">
<p>通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p>
</div>
<div id="rlrbranch_b" class="imageblock">
<div class="content"><img src="static/picture/lr-branches-2.png" alt="渐进稳定分支的工作流（“silo”）视图。"></div>
<div class="title">Figure 27. 渐进稳定分支的流水线（“silo”）视图</div>
</div>
<div class="paragraph">
<p>你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 next 或者 master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</p>
</div>
</div>
<div class="sect3">
<p id="r_topic_branch"><strong>特性分支</strong></p>
<div class="paragraph">
<p>特性分支对任何规模的项目都适用。 特性分支是一种短期分支，它被用来实现单一特性或其相关工作。 也许你从来没有在其他的版本控制系统（VCS）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。 然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。</p>
</div>
<div class="paragraph">
<p>你已经在上一节中你创建的 iss53 和 hotfix 特性分支中看到过这种用法。 你在上一节用到的特性分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p>
</div>
<div class="paragraph">
<p>考虑这样一个例子，你在 master 分支上工作到 C1，这时为了解决一个问题而新建 iss91 分支，在 iss91分支上工作到 C4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 C10的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/topic-branches-1.png" alt="拥有多个特性分支的提交历史。"></div>
<div class="title">Figure 28. 拥有多个特性分支的提交历史</div>
</div>
<div class="paragraph">
<p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 <code>iss91v2</code> 分支中方案；另外，你将 <code>dumbidea</code> 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 <code>iss91</code> 分支（即丢弃 <code>C5</code> 和 <code>C6</code> 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/topic-branches-2.png" alt="合并了 &#96;dumbidea&#96; 和 &#96;iss91v2&#96; 分支之后的提交历史。"></div>
<div class="title">Figure 29. 合并了 <code>dumbidea</code> 和 <code>iss91v2</code> 分支之后的提交历史</div>
</div>
<div class="paragraph">
<p>请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。</p>
<h1 id="r_remote_branches" id="%e8%bf%9c%e7%a8%8b%e5%88%86%e6%94%af"><span id="i-5">远程分支</span></h1>
<div class="paragraph">
<p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 <code>git ls-remote (remote)</code> 来显式地获得远程引用的完整列表，或者通过 <code>git remote show (remote)</code> 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</p>
</div>
<div class="paragraph">
<p>远程跟踪分支是远程分支状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。</p>
</div>
<div class="paragraph">
<p>它们以 <code>(remote)/(branch)</code> 形式命名。 例如，如果你想要看你最后一次与远程仓库 <code>origin</code> 通信时 <code>master</code>分支的状态，你可以查看 <code>origin/master</code> 分支。 你与同事合作解决一个问题并且他们推送了一个 <code>iss53</code> 分支，你可能有自己的本地 <code>iss53</code> 分支；但是在服务器上的分支会指向 <code>origin/iss53</code> 的提交。</p>
</div>
<div class="paragraph">
<p>这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 <code>git.ourcompany.com</code> 的 Git 服务器。 如果你从这里克隆，Git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code>拉取它的所有数据，创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为 <code>origin/master</code> Git 也会给你一个与 origin 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支，这样你就有工作的基础。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">“origin” 并无特殊含义</div>
<div class="paragraph">
<p>远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 <code>git init</code> 时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行 <code>git clone</code> 时默认的远程仓库名字。 如果你运行 <code>git clone -o booyah</code>，那么你默认的远程分支名字将会是 <code>booyah/master</code>。</p>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/remote-branches-1.png" alt="克隆之后的服务器与本地仓库。"></div>
<div class="title">Figure 30. 克隆之后的服务器与本地仓库</div>
</div>
<div class="paragraph">
<p>如果你在本地的 <code>master</code> 分支做了一些工作，然而在同一时间，其他人推送提交到 <code>git.ourcompany.com</code> 并更新了它的 <code>master</code> 分支，那么你的提交历史将向不同的方向前进。 也许，只要你不与 origin 服务器连接，你的 <code>origin/master</code> 指针就不会移动。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/remote-branches-2.png" alt="本地与远程的工作可以分叉。"></div>
<div class="title">Figure 31. 本地与远程的工作可以分叉</div>
</div>
<div class="paragraph">
<p>如果要同步你的工作，运行 git fetch origin 命令。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com），从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master指针指向新的、更新后的位置。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/remote-branches-3.png" alt="&#96;git fetch&#96; 更新你的远程仓库引用。"></div>
<div class="title">Figure 32. <code>git fetch</code> 更新你的远程仓库引用</div>
</div>
<div class="paragraph">
<p>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅用于你的 sprint 小组的开发工作。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 Git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为整个 URL 的缩写。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/remote-branches-4.png" alt="添加另一个远程仓库。"></div>
<div class="title">Figure 33. 添加另一个远程仓库</div>
</div>
<div class="paragraph">
<p>现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集，所以 Git 并不会抓取数据而是会设置远程跟踪分支 teamone/master 指向 teamone 的 master 分支。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/remote-branches-5.png" alt="远程跟踪分支 &#96;teamone/master&#96;。"></div>
<div class="title">Figure 34. 远程跟踪分支 <code>teamone/master</code></div>
</div>
<div class="sect3">
<p>&nbsp;</p>
<p id="r_pushing_branches"><strong>推送</strong></p>
<div class="paragraph">
<p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步 &#8211; 你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p>
</div>
<div class="paragraph">
<p>如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push (remote) (branch):</p>
</div>
<p><code class="language-console" data-lang="console">$ git push origin serverfix<br>
Counting objects: 24, done.<br>
Delta compression using up to 8 threads.<br>
Compressing objects: 100% (15/15), done.<br>
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.<br>
Total 24 (delta 2), reused 0 (delta 0)<br>
To https://github.com/schacon/simplegit<br>
* [new branch]      serverfix -&gt; serverfix</code></p>
</div>
</div>
<div class="paragraph">
<p>这里有些工作被简化了。 Git 自动将 <code>serverfix</code> 分支名字展开为 <code>refs/heads/serverfix:refs/heads/serverfix</code>那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 。 你也可以运行 <code>git push origin serverfix:serverfix</code>它会做同样的事 &#8211; 相当于它说，“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 <code>serverfix</code>可以运行 <code>git push origin serverfix:awesomebranch</code> 来将本地的 <code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code> 分支。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">如何避免每次输入密码</div>
<div class="paragraph">
<p>如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。</p>
</div>
<div class="paragraph">
<p>如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 <code>git config --global credential.helper cache</code> 来设置它。</p>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 <code>origin/serverfix</code>指向服务器的 <code>serverfix</code> 分支的引用：</p>
</div>
<p><code class="language-console" data-lang="console">$ git fetch origin<br>
remote: Counting objects: 7, done.<br>
remote: Compressing objects: 100% (2/2), done.<br>
remote: Total 3 (delta 0), reused 3 (delta 0)<br>
Unpacking objects: 100% (3/3), done.<br>
From https://github.com/schacon/simplegit<br>
* [new branch]      serverfix    -&gt; origin/serverfix</code></p>
</div>
</div>
<div class="paragraph">
<p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 <code>serverfix</code> 分支 &#8211; 只有一个不可以修改的 <code>origin/serverfix</code> 指针。</p>
</div>
<div class="paragraph">
<p>可以运行 <code>git merge origin/serverfix</code> 将这些工作合并到当前所在的分支。 如果想要在自己的 <code>serverfix</code> 分支上工作，可以将其建立在远程跟踪分支之上：</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout -b serverfix origin/serverfix<br>
Branch serverfix set up to track remote branch serverfix from origin.<br>
Switched to a new branch 'serverfix'</code></p>
<div class="paragraph">
<p>这会给你一个用于工作的本地分支，并且起点位于 <code>origin/serverfix</code></p>
</div>
<div class="sect3">
<p id="r_tracking_branches"><strong>跟踪分支</strong></p>
<div class="paragraph">
<p>从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
</div>
<div class="paragraph">
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 &#8211; 其他远程仓库上的跟踪分支，或者不跟踪 master 分支。 最简单的就是之前看到的例子，运行 git checkout -b [branch] [remotename]/[branch]。 这是一个十分常用的操作所以 Git 提供了 &#8211;track 快捷方式：</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout --track origin/serverfix<br>
Branch serverfix set up to track remote branch serverfix from origin.<br>
Switched to a new branch 'serverfix'</code></p>
</div>
<div class="paragraph">
<p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地增加一个不同名字的本地分支的上一个命令：</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout -b sf origin/serverfix<br>
Branch sf set up to track remote branch serverfix from origin.<br>
Switched to a new branch 'sf'</code></p>
<div class="paragraph">
<p>现在，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p>
</div>
<div class="paragraph">
<p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p>
</div>
<p><code class="language-console" data-lang="console">$ git branch -u origin/serverfix<br>
Branch serverfix set up to track remote branch serverfix from origin.</code></p>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">上游快捷方式</div>
<div class="paragraph">
<p>当设置好跟踪分支后，可以通过 @{upstream} 或 @{u} 快捷方式来引用它。 所以在 master分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u} 来取代 git merge origin/master。</p>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p>
</div>
<p><code class="language-console" data-lang="console">$ git branch -vv<br>
iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets<br>
master    1ae2a45 [origin/master] deploying index fix<br>
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it<br>
testing   5ea463a trying something new</code></p>
<div class="paragraph">
<p>这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。</p>
</div>
<div class="paragraph">
<p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：$ git fetch &#8211;all; git branch -vv</p>
</div>
<div class="sect3">
<p id="_拉取"><strong>拉取</strong></p>
<div class="paragraph">
<p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 <code>git pull</code> 在大多数情况下它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 <code>clone</code> 或 <code>checkout</code> 命令为你创建的，<code>git pull</code> 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p>
</div>
<div class="paragraph">
<p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用 <code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p>
</div>
</div>
<div class="sect3">
<p id="r_delete_branches"><strong>删除远程分支</strong></p>
<div class="paragraph">
<p>假设你已经通过远程分支做完所有的工作了 &#8211; 也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 <code>master</code> 分支（或任何其他稳定代码分支）。 可以运行带有 <code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 如果想要从服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p>
</div>
<p><code class="language-console" data-lang="console">$ git push origin --delete serverfix<br>
To https://github.com/schacon/simplegit<br>
- [deleted]         serverfix</code></p>
</div>
<div class="paragraph">
<p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<h1 id="r_rebasing" id="%e5%8f%98%e5%9f%ba"><span id="i-6">变基</span></h1>
<div class="paragraph">
<p>在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p>
</div>
<div class="sect3">
<p id="_变基的基本操作"><strong>变基的基本操作</strong></p>
<div class="paragraph">
<p>请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/basic-rebase-1.png" alt="分叉的提交历史。"></div>
<div class="title">Figure 35. 分叉的提交历史</div>
</div>
<div class="paragraph">
<p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/basic-rebase-2.png" alt="通过合并操作来整合分叉了的历史。"></div>
<div class="title">Figure 36. 通过合并操作来整合分叉了的历史</div>
</div>
<div class="paragraph">
<p>其实，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在 Git 中，这种操作就叫做 <em>变基</em>。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p>
</div>
<div class="paragraph">
<p>在上面这个例子中，运行：</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout experiment<br>
$ git rebase master<br>
First, rewinding head to replay your work on top of it...<br>
Applying: added staged command</code></p>
</div>
</div>
<div class="paragraph">
<p>它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同）</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/basic-rebase-3.png" alt="将 &#96;C4&#96; 中的修改变基到 &#96;C3&#96; 上。"></div>
<div class="title">Figure 37. 将 C4 中的修改变基到 C3 上</div>
</div>
<div class="paragraph">
<p>现在回到 master 分支，进行一次快进合并。</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout master<br>
$ git merge experiment</code></p>
<div class="imageblock">
<div class="content"><img src="static/picture/basic-rebase-4.png" alt="master 分支的快进合并。"></div>
<div class="title">Figure 38. master 分支的快进合并</div>
</div>
<div class="paragraph">
<p>此时，C4&#8242; 指向的快照就和上面使用 merge 命令的例子中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p>
</div>
<div class="paragraph">
<p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p>
</div>
<div class="paragraph">
<p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>
</div>
<div class="sect3">
<p id="_更有趣的变基例子"><strong>更有趣的变基例子</strong></p>
<div class="paragraph">
<p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。  你创建了一个特性分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了特性分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。</p>
</div>
<div id="rrbdiag_e" class="imageblock">
<div class="content"><img src="static/picture/interesting-rebase-1.png" alt="从一个特性分支里再分出一个特性分支的提交历史。"></div>
<div class="title">Figure 39. 从一个特性分支里再分出一个特性分支的提交历史</div>
</div>
<div class="paragraph">
<p>假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 git rebase 命令的 &#8211;onto 选项，选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：</p>
</div>
<p><code class="language-console" data-lang="console">$ git rebase --onto master server client</code></p>
</div>
<div class="paragraph">
<p>以上命令的意思是：“取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重放一遍”。 这理解起来有一点复杂，不过效果非常酷。</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/interesting-rebase-2.png" alt="截取特性分支上的另一个特性分支，然后变基到其他分支。"></div>
<div class="title">Figure 40. 截取特性分支上的另一个特性分支，然后变基到其他分支</div>
</div>
<div class="paragraph">
<p>现在可以快进合并 master 分支了。（如图 快进合并 master 分支，使之包含来自 client 分支的修改）：</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout master<br>
$ git merge client</code></p>
<div id="rrbdiag_g" class="imageblock">
<div class="content"><img src="static/picture/interesting-rebase-3.png" alt="快进合并 master 分支，使之包含来自 client 分支的修改。"></div>
<div class="title">Figure 41. 快进合并 master 分支，使之包含来自 client 分支的修改</div>
</div>
<div class="paragraph">
<p>接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase [basebranch] [topicbranch] 命令可以直接将特性分支（即本例中的 server）变基到目标分支（即 master）上。这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。</p>
</div>
<p><code class="language-console" data-lang="console">$ git rebase master server</code></p>
<div class="paragraph">
<p>如图 将 server 中的修改变基到 master上 所示，server 中的代码被“续”到了 master 后面。</p>
</div>
<div id="rrbdiag_h" class="imageblock">
<div class="content"><img src="static/picture/interesting-rebase-4.png" alt="将 server 中的修改变基到 master 上。"></div>
<div class="title">Figure 42. 将 server 中的修改变基到 master 上</div>
</div>
<div class="paragraph">
<p>然后就可以快进合并主分支 master 了：</p>
</div>
<p><code class="language-console" data-lang="console">$ git checkout master<br>
$ git merge server</code></p>
<div class="paragraph">
<p>至此，client 和 server 分支中的修改都已经整合到主分支里了，你可以删除这两个分支，最终提交历史会变成图 最终的提交历史 中的样子：</p>
</div>
<p><code class="language-console" data-lang="console">$ git branch -d client<br>
$ git branch -d server</code></p>
<div id="rrbdiag_i" class="imageblock">
<div class="content"><img src="static/picture/interesting-rebase-5.png" alt="最终的提交历史。"></div>
<div class="title">Figure 43. 最终的提交历史</div>
</div>
<div class="sect3">
<p>&nbsp;</p>
<p id="r_rebase_peril"><strong>变基的风险</strong></p>
<div class="paragraph">
<p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p>
</div>
<div class="paragraph">
<p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p>
</div>
<div class="paragraph">
<p>如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>
</div>
<div class="paragraph">
<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>
</div>
<div class="paragraph">
<p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/perils-of-rebasing-1.png" alt="克隆一个仓库，然后在它的基础上进行了一些开发。"></div>
<div class="title">Figure 44. 克隆一个仓库，然后在它的基础上进行了一些开发</div>
</div>
<div class="paragraph">
<p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p>
</div>
<div class="imageblock">
<div class="content"><img src="static/picture/perils-of-rebasing-2.png" alt="抓取别人的提交，合并到自己的开发分支。"></div>
<div class="title">Figure 45. 抓取别人的提交，合并到自己的开发分支</div>
</div>
<div class="paragraph">
<p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p>
</div>
<div id="r_pre_merge_rebase_work" class="imageblock">
<div class="content"><img src="static/picture/perils-of-rebasing-3.png" alt="有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。"></div>
<div class="title">Figure 46. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</div>
</div>
<div class="paragraph">
<p>结果就是你们两人的处境都十分尴尬。 如果你执行 git pull 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p>
</div>
<div id="r_merge_rebase_work" class="imageblock">
<div class="content"><img src="static/picture/perils-of-rebasing-4.png" alt="你将相同的内容又合并了一次，生成了一个新的提交。"></div>
<div class="title">Figure 47. 你将相同的内容又合并了一次，生成了一个新的提交</div>
</div>
<div class="paragraph">
<p>此时如果你执行 git log 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 C4 和 <code>C6</code>，因为之前就是他把这两个提交通过变基丢弃的。</p>
</div>
</div>
<div class="sect3">
<p id="r_rebase_rebase"><strong>用变基解决变基</strong></p>
<div class="paragraph">
<p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p>
</div>
<div class="paragraph">
<p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和—— 即 “patch-id”。</p>
</div>
<div class="paragraph">
<p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p>
</div>
<div class="paragraph">
<p>举个例子，如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情境，如果我们不是执行合并，而是执行 <code>git rebase teamone/master</code>, Git 将会：</p>
</div>
<div class="ulist">
<ul>
<li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li>
<li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li>
<li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4&#8217;）</li>
<li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li>
</ul>
</div>
<div class="paragraph">
<p>从而我们将得到与 你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果，如图 在一个被变基然后强制推送的分支上再次执行变基 所示。</p>
</div>
<div id="r_rebase_rebase_work" class="imageblock">
<div class="content"><img src="static/picture/perils-of-rebasing-5.png" alt="在一个被变基然后强制推送的分支上再次执行变基。"></div>
<div class="title">Figure 48. 在一个被变基然后强制推送的分支上再次执行变基</div>
</div>
<div class="paragraph">
<p>要想上述方案有效，还需要对方在变基时确保 C4&#8242; 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p>
</div>
<div class="paragraph">
<p>在本例中另一种简单的方法是使用 git pull &#8211;rebase 命令而不是直接 git pull。 又或者你可以自己手动完成这个过程，先 git fetch，再 git rebase teamone/master。</p>
</div>
<div class="paragraph">
<p>如果你习惯使用 git pull ，同时又希望默认使用选项 &#8211;rebase，你可以执行这条语句 git config &#8211;global pull.rebase true 来更改 pull.rebase 的默认配置。</p>
</div>
<div class="paragraph">
<p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，就不会有事。 假如在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。</p>
</div>
<div class="paragraph">
<p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull &#8211;rebase 命令，这样尽管不能避免伤痛，但能有所缓解。</p>
</div>
</div>
<div class="sect3">
<p id="_变基_vs_合并"><strong>变基 vs. 合并</strong></p>
<div class="paragraph">
<p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p>
</div>
<div class="paragraph">
<p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用_谎言_掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p>
</div>
<div class="paragraph">
<p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。</p>
</div>
<div class="paragraph">
<p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p>
</div>
<div class="paragraph">
<p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>
<h1 id="_总结_3" id="%e6%80%bb%e7%bb%93"><span id="i-7">总结</span></h1>
<div class="paragraph">
<p>我们已经讲完了 Git 分支与合并的基础知识。 你现在应该能自如地创建并切换至新分支、在不同分支之间切换以及合并本地分支。 你现在应该也能通过推送你的分支至共享服务以分享它们、使用共享分支与他人协作以及在共享之前使用变基操作合并你的分支。 下一章，我们将要讲到，如果你想要运行自己的 Git 仓库托管服务器，你需要知道些什么。</p>
</div>
</div>
</div>
<!-- /.hkb-article__content -->


					


					 

					
			</div>			

		</div></article>

		
		

<!-- .hkb-article__related -->
    <section class="hkb-article-related" class="clearfix">
        <h3 class="hkb-article-related__title">相关文章</h3>
        <ul class="hkb-article-list">
        
            <li class="xianguanwenzhang hkb-article-list__format-standard">
                <a href="git-base.html" title="Git 基础操作">Git 基础操作</a>
                     <!-- .hkb-meta -->
    <ul class="hkb-meta">

                            <li class="hkb-meta__views">
    9797</li>                        
    </ul>
    <!-- /.hkb-meta -->
            </li>

        
            <li class="xianguanwenzhang hkb-article-list__format-standard">
                <a href="git-start.html" title="Git 快速入门">Git 快速入门</a>
                     <!-- .hkb-meta -->
    <ul class="hkb-meta">

                            <li class="hkb-meta__views">
    12964</li>                        
    </ul>
    <!-- /.hkb-meta -->
            </li>

        
            <li class="xianguanwenzhang hkb-article-list__format-standard">
                <a href="git-command.html" title="Git 常见命令">Git 常见命令</a>
                     <!-- .hkb-meta -->
    <ul class="hkb-meta">

                            <li class="hkb-meta__views">
    6662</li>                        
    </ul>
    <!-- /.hkb-meta -->
            </li>

                </ul>
    </section>
<!-- /.hkb-article__related -->


		
	
</div><!-- /#ht-kb -->
</main>
<!-- /#content -->


<!-- #sidebar -->
<aside id="sidebar" role="complementary" itemtype="http://schema.org/WPSideBar" itemscope="itemscope">
	<section id="custom_html-5" class="widget_text widget widget_custom_html clearfix"><div class="textwidget custom-html-widget"><a href="quick-start.html"><img src="static/picture/beaa7550-1350-4c46-b12d-52414125.png" class="help-banner"></a>
<a href="safe.html"><img src="static/picture/27b960ca-cad4-426f-9b70-48940704.png" class="help-banner"></a>


<style>
.help-banner{
width:100%;
}
#sidebar .widget#custom_html-5{
padding:0px;
}
#sidebar .widget#custom_html-5 a{
display:block;
line-height:0px;
}
</style>

</div></section><section id="ht-kb-categories-widget-4" class="widget hkb_widget_categories clearfix"><h4 class="widget-title">帮助文档目录</h4><ul class="hkb_category_widget__category_list">	<li class="cat-item cat-item-60"><a href="quick-start.html">快速入门</a>
</li>
	<li class="cat-item cat-item-61"><a href="faq.html">常见问题</a>
</li>
	<li class="cat-item cat-item-62"><a href="git-2.html">Git帮助手册</a>
</li>
	<li class="cat-item cat-item-56"><a href="cloud-studio.html">Cloud Studio</a>
</li>
</ul></section><section id="ht-kb-exit-widget-3" class="widget hkb_widget_exit clearfix"><h4 class="widget-title">依然找不到解决办法？</h4><div class="hkb_widget_exit__content">点击下方链接提交反馈</div><a class="hkb_widget_exit__btn" href="javascript:;" target="_blank">提交反馈</a></section></aside>
<!-- /#sidebar -->


</div>
<!-- /.ht-container -->
</div>
<!-- /#primary -->

<!-- #site-footer-widgets -->
<section id="site-footer-widgets" style="display: none;">
<div class="ht-container">


</div>
</section>
<!-- /#site-footer-widgets -->
<style>
body {
  -webkit-font-smoothing: antialiased;
}
.footer-container {
  height: 150px;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  background-color: #1f2530;
  padding: 0 20px;
  color: #fff;
  line-height: 1.5;
}
.footer-container .nav {
  font-size: 14px;
  margin-bottom: 15px;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  opacity: 0.8;
}
.footer-container .nav .item {
  font-size: 14px;
  margin-right: 40px;
  text-decoration: unset;
  color: #fff;
}
.footer-container .right {
  color: #fff;
  font-size: 12px;
  opacity: 0.6;
}
.footer-container .items {
  font-size: 12px;
  opacity: 0.6;
  margin-bottom: 3px;
}
.footer-container .items a {
  color: #fff;
  text-decoration: unset;
}
@media only screen and (max-width: 414px) {
  .footer-container {
    height: 200px;
  }
  .footer-container .nav {
    font-size: 14px;
    color: #fff;
    justify-content: center;
    margin-bottom: 4px;
  }
  .footer-container .nav .first-row {
    margin-bottom: 10px;
  }
  .footer-container .nav .first-row a {
    margin-right: 0;
  }
  .footer-container .nav .second-row {
    margin-bottom: 20px;
  }
  .footer-container .nav .second-row a {
    margin-right: 10px;
  }
  .footer-container .nav .second-row a:last-of-type {
    margin-right: 0;
  }
  .footer-container .nav .item {
    font-size: 14px;
  }
  .footer-container .items {
    margin-bottom: 12px;
  }
}


</style>

<!-- #site-footer -->
<footer class="footer-container">
    <div class="nav">
        <div class="first-row">
            <a href="help.html" target="_blank" class="item">
                文档帮助
            </a>
            <a href="index2.html" class="item" target="_blank">
                腾讯云官网
            </a>
        </div>
        <div class="second-row">

            <a href="developer.html" class="item" target="_blank">
                腾讯云+社区
            </a>
            <a href="about.html" target="_blank" class="item">
                关于我们
            </a>
            <a href="javascript:;" class="item" target="_blank" style="margin-right: 0">
                在线反馈
            </a>
        </div>
    </div>
    <div class="items"><a href="privacy.html" target="_blank">隐私策略</a>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<a href="terms.html" target="_blank">服务条款</a>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<a href="security.html" target="_blank">安全策略</a></div>
    <div class="right">
        Copyright © 2013-2019 Tencent Cloud. All Rights Reserved. 腾讯云 版权所有&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;粤B2-20090059
    </div>
</footer>
<!-- /#site-footer -->

<script type='text/javascript' src='static/js/jquery.livesearch-4.8.12.js'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var hkbJSSettings = {"liveSearchUrl":"https:\/\/dev.tencent.com\/help\/?ajax=1&ht-kb-search=1&s=","focusSearchBox":"1"};
/* ]]> */
</script>
<script type='text/javascript' src='static/js/hkb-livesearch-js-4.8.12.js'></script>
<script type='text/javascript' src='static/js/front.min-1509.js'></script>
<script type='text/javascript' src='static/js/functions-4.8.12.js'></script>
<script type='text/javascript' src='static/js/jquery-picture-min-4.8.12.js'></script>
<script type='text/javascript' src='static/js/wp-embed.min-4.8.12.js'></script>

</div>
<!-- /#site-container -->
</body>
</html>